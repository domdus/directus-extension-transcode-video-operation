import e from"fs";import i from"path";import{exec as t}from"child_process";var o={id:"transcode-video-operation",handler:async({file:o,folder_id:r,playlist_reference_type:n="id",qualities:a=["240p","480p","720p","1080p","2160p"],threads:s=1,nice:d,storage_adapter:c="default",target_storage:l},{env:p,services:f,getSchema:u,logger:m})=>{if(!o)throw m.info("[transcode-video-operation] Input file missing"),new Error("Input file missing");if(!r)throw m.info("[transcode-video-operation] folder_id parameter is required"),new Error("folder_id parameter is required");let h;if("string"==typeof o)try{const{FilesService:e}=f,i=new e({schema:await u()});h=await i.readOne(o),m.info(`[transcode-video-operation] Fetched file from UUID: ${o}`)}catch(e){throw m.error(`[transcode-video-operation] Error fetching file with UUID ${o}:`,e),new Error(`Failed to fetch file with UUID ${o}: ${e instanceof Error?e.message:String(e)}`)}else h=o;if(!h?.filename_disk)throw m.info("[transcode-video-operation] Input file missing filename_disk"),new Error("Input file missing filename_disk");const $=h.filename_disk.split(".")[0];h.filename_disk.substr(h.filename_disk.lastIndexOf(".")+1);const g=p.STORAGE_LOCATIONS?p.STORAGE_LOCATIONS.split(",").map((e=>e.trim())):[],v=g.length>0?g[0]:"local";let _,y;"source"===c?_=h.storage||v:"custom"===c&&l?g.includes(l)?_=l:(m.warn(`[transcode-video-operation] (${$}) Custom storage "${l}" not found in configured locations. Using default.`),_=v):_=v,m.info(`[transcode-video-operation] (${$}) Using storage adapter: ${_}`);const w=e=>{const i=`STORAGE_${e.toUpperCase()}_DRIVER`,t=p[i];return t?String(t):(m.warn(`[transcode-video-operation] (${$}) No driver found for storage location <%s>, assuming 'local'`,e),"local")},S=i=>e.readdirSync(i,"utf-8").filter((e=>e.startsWith($))),b=async(t,o=null,r={})=>{try{const{FilesService:n}=f,a=new n({schema:await u()}),s=i.basename(t),d=s.substr(s.lastIndexOf(".")+1),c=e.statSync(t).size,l={ts:"video/mp2t",mp4:"video/mp4",jpeg:"image/jpeg",jpg:"image/jpeg",m3u8:"application/x-mpegurl"},p=r.storage||_,m=r.mimetype||l[d]||"application/octet-stream",h={filename_disk:{_eq:s},storage:{_eq:p}};h.folder=o?{_eq:o}:{_null:!0};const $=await a.readByQuery({filter:h,limit:1});if($&&Array.isArray($)&&$.length>0){const e=$[0],i=e?.id||e?.data?.id||("string"==typeof e?e:null);if(i)return String(i)}const g=e.createReadStream(t),v={storage:p,filename_disk:s,filename_download:s,title:s,type:m,filesize:c};void 0!==r.width&&null!==r.width&&(v.width=r.width),void 0!==r.height&&null!==r.height&&(v.height=r.height),o&&(v.folder=o);const y=await a.createOne(v,{file:g,title:s}),w=y?.id||y?.data?.id||("string"==typeof y?y:null);if(!w)throw new Error(`Failed to get file ID from response. Response: ${JSON.stringify(y)}`);return String(w)}catch(e){throw m.error(`[transcode-video-operation] (${$}) Error creating file record for ${t}:`,e),e}},k=(t,o,r=!1)=>{const n=e.readFileSync(t,"utf-8").split("\n"),a=[],s=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;for(const e of n)if(e.startsWith("#")||""===e.trim())a.push(e);else{let t=e.trim();if(t.startsWith("/assets/")&&(t=t.substring(8)),s.test(t)&&!r){a.push(t);continue}const n=i.basename(t),d=o[t]||o[n];d?r?a.push(t):a.push(d):a.push(e)}return a.join("\n")};function E(e,i,o,r){return new Promise(((n,a)=>{const s="win32"===process.platform,d=s||null==r?"":`nice -n ${r} `;s&&null!=r&&m.warn(`[transcode-video-operation] (${$}) Nice value (${r}) specified but running on Windows - nice command not available, ignoring priority setting`);const c=`${d}ffmpeg -y -i ${e} -threads ${o} ${i.options}`;t(c,((e,t,o)=>e?(m.error(`[transcode-video-operation] (${$}) Error occured for quality: %s`,i.id),m.error(e.message),m.error(`stdout: ${t}`),m.error(`stderr: ${o}`),void a(new Error(`FFmpeg transcoding failed for quality ${i.id}p: ${e.message}. stderr: ${o}`))):o&&(o.includes("not found")||o.includes("command not found"))?(m.error(`[transcode-video-operation] (${$}) FFmpeg not found in stderr for quality: %s`,i.id),m.error(`stderr: ${o}`),void a(new Error(`FFmpeg command not found. stderr: ${o}`))):(m.info(`[transcode-video-operation] (${$}) Transcoding finished for quality: %s`,i.id),void n(t.trim()))))}))}m.info(`[transcode-video-operation] (${$}) Operation started`);const I=null!=s?parseInt(String(s),10):1,F=isNaN(I)||I<0?1:I;let x,T;if(null!=d){const e=parseInt(String(d),10);!isNaN(e)&&e>=0&&e<=19?x=e:m.warn(`[transcode-video-operation] (${$}) Invalid nice value: ${d}. Must be between 0 and 19. Ignoring.`)}let N=null,O=!1;const q=w(h.storage);if("local"===q){const t=(e=>{const i=`STORAGE_${e.toUpperCase()}_ROOT`,t=p[i];return t?String(t):(m.warn(`[transcode-video-operation] (${$}) No storage found for location <%s>`,e),null)})(h.storage);if(!t)return{error:`No storage found for location <${h.storage}>`};const o=process.env.PWD||"/directus";if(T=i.join(o,`${t}/${h.filename_disk}`),!e.existsSync(T))return m.error(`[transcode-video-operation] (${$}) Source file not found: %s`,T),{error:`Source file not found: ${T}`}}else{m.info(`[transcode-video-operation] (${$}) Source file is in cloud storage (${h.storage}, driver: ${q}), downloading to temporary location...`);try{const t=h.id||("string"==typeof o?o:null);if(!t)return{error:"Cannot download source file: file ID not found"};const r=i.join(process.env.PWD||"/directus","tmp","transcode");e.existsSync(r)||e.mkdirSync(r,{recursive:!0});const n=i.join(r,`${t}_${h.filename_disk}`);N=n;const a=`${p.PUBLIC_URL||"http://localhost:8055"}/assets/${t}`,s=require("https"),d=require("http");await new Promise(((i,t)=>{(a.startsWith("https")?s:d).get(a,(o=>{if(200!==o.statusCode)return void t(new Error(`Failed to download file: HTTP ${o.statusCode}`));const r=e.createWriteStream(n);o.pipe(r),r.on("finish",(()=>{r.close(),i()})),r.on("error",t)})).on("error",t)})),T=N,O=!0,m.info(`[transcode-video-operation] (${$}) Source file downloaded to: ${T}`)}catch(e){return m.error(`[transcode-video-operation] (${$}) Error downloading source file from cloud storage:`,e),{error:`Failed to download source file from cloud storage: ${e instanceof Error?e.message:String(e)}`}}}y=i.dirname(T),m.info(`[transcode-video-operation] (${$}) File to be transcoded: %s`,T),m.info(`[transcode-video-operation] (${$}) Output directory: %s`,y),e.existsSync(y)||(e.mkdirSync(y,{recursive:!0}),m.info(`[transcode-video-operation] (${$}) Folder created`));try{await new Promise(((e,i)=>{t("which ffmpeg",((t,o,r)=>{!t&&o.trim()?e():i(new Error("FFmpeg is not installed or not found in PATH. Please install ffmpeg."))}))})),m.info(`[transcode-video-operation] (${$}) FFmpeg is available`)}catch(e){throw m.error(`[transcode-video-operation] (${$}) FFmpeg check failed: %s`,e instanceof Error?e.message:String(e)),e}const A=await new Promise(((e,i)=>{t(`ffprobe -v error -select_streams v:0 -show_entries stream=pix_fmt -of json ${T}`,((i,t)=>{if(i)return m.warn(`[transcode-video-operation] (${$}) Error checking bit depth, assuming 8-bit: %s`,i.message),void e(!1);try{const i=JSON.parse(t),o=i.streams?.[0]?.pix_fmt;e(o?.includes("10")||!1)}catch(i){m.warn(`[transcode-video-operation] (${$}) Error parsing bit depth check, assuming 8-bit`),e(!1)}}))}));A&&m.info(`[transcode-video-operation] (${$}) High bit depth detected, will convert to yuv420p`),m.info(`[transcode-video-operation] (${$}) Getting source video metadata...`);const D=await(async e=>new Promise(((i,o)=>{t(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height:format=duration -of json ${e}`,((e,t)=>{if(e)return m.error(`[transcode-video-operation] (${$}) Error getting video metadata:`,e),void o(e);try{const e=JSON.parse(t),r=e.streams?.[0],n=e.format;if(!r||!r.width||!r.height)return void o(new Error("Could not get video dimensions"));const a=parseInt(r.width),s=parseInt(r.height),d=n?.duration?Math.floor(1e3*parseFloat(n.duration)):0;i({width:a,height:s,isVertical:s>a,duration:d})}catch(e){m.error(`[transcode-video-operation] (${$}) Error parsing metadata:`,e),o(e)}}))})))(T).catch((e=>(m.error(`[transcode-video-operation] (${$}) Error getting source metadata:`,e),{width:99999,height:99999,isVertical:!1,duration:0}))),R=D.height;m.info(`[transcode-video-operation] (${$}) Source video resolution: ${D.width}x${R}`);const C=((e=!1)=>{const i="main",t=e?"format=yuv420p,":"";return[{id:240,options:`-vf "${t}scale=w='min(426,iw)':h='min(240,ih)':force_original_aspect_ratio=decrease,scale=trunc(iw/2)*2:trunc(ih/2)*2" -c:a aac -ar 48000 -c:v h264 -profile:v ${i} -crf 22 -sc_threshold 0 -g 48 -keyint_min 48 -hls_time 4 -hls_playlist_type vod -b:v 400k -maxrate 428k -bufsize 600k -b:a 64k -hls_segment_filename ${y}/${$}_240p_%03d.ts ${y}/${$}_240p.m3u8`},{id:480,options:`-vf "${t}scale=w='min(854,iw)':h='min(480,ih)':force_original_aspect_ratio=decrease,scale=trunc(iw/2)*2:trunc(ih/2)*2" -c:a aac -ar 48000 -c:v h264 -profile:v ${i} -crf 20 -sc_threshold 0 -g 48 -keyint_min 48 -hls_time 4 -hls_playlist_type vod -b:v 1400k -maxrate 1498k -bufsize 2100k -b:a 128k -hls_segment_filename ${y}/${$}_480p_%03d.ts ${y}/${$}_480p.m3u8`},{id:720,options:`-vf "${t}scale=w='min(1280,iw)':h='min(720,ih)':force_original_aspect_ratio=decrease,scale=trunc(iw/2)*2:trunc(ih/2)*2" -c:a aac -ar 48000 -c:v h264 -profile:v ${i} -crf 20 -sc_threshold 0 -g 48 -keyint_min 48 -hls_time 4 -hls_playlist_type vod -b:v 2800k -maxrate 2996k -bufsize 4200k -b:a 128k -hls_segment_filename ${y}/${$}_720p_%03d.ts ${y}/${$}_720p.m3u8`},{id:1080,options:`-vf "${t}scale=w='min(1920,iw)':h='min(1080,ih)':force_original_aspect_ratio=decrease,scale=trunc(iw/2)*2:trunc(ih/2)*2" -c:a aac -ar 48000 -c:v h264 -profile:v ${i} -crf 20 -sc_threshold 0 -g 48 -keyint_min 48 -hls_time 4 -hls_playlist_type vod -b:v 5000k -maxrate 5350k -bufsize 7500k -b:a 192k -hls_segment_filename ${y}/${$}_1080p_%03d.ts ${y}/${$}_1080p.m3u8`},{id:2160,options:`-vf "${t}scale=w='min(3840,iw)':h='min(2160,ih)':force_original_aspect_ratio=decrease,scale=trunc(iw/2)*2:trunc(ih/2)*2" -c:a aac -ar 48000 -c:v h264 -profile:v ${i} -crf 20 -sc_threshold 0 -g 48 -keyint_min 48 -hls_time 4 -hls_playlist_type vod -b:v 20000k -maxrate 21400k -bufsize 30000k -b:a 192k -hls_segment_filename ${y}/${$}_2160p_%03d.ts ${y}/${$}_2160p.m3u8`}]})(A);let W=["240p","480p","720p","1080p","2160p"];if(a)if(Array.isArray(a))W=a;else if("string"==typeof a)try{W=JSON.parse(a)}catch(e){m.warn(`[transcode-video-operation] (${$}) Could not parse qualities, using all:`,e)}const U=W.map((e=>{if("string"==typeof e){const i=e.replace(/p$/i,"");return parseInt(i,10)}return e})).filter((e=>!isNaN(e))),j={240:240,480:480,720:720,1080:1080,2160:2160};let P=C.filter((e=>U.includes(e.id)));const X=P.length;if(P=P.filter((e=>{const i=j[e.id];return!(i&&i>R)||(m.info(`[transcode-video-operation] (${$}) Skipping ${e.id}p (target: ${i}px, source: ${R}px) to prevent upscaling`),!1)})),X>P.length&&m.info(`[transcode-video-operation] (${$}) Filtered out ${X-P.length} quality level(s) that would require upscaling`),m.info(`[transcode-video-operation] (${$}) Selected qualities: ${U.join(", ")}`),m.info(`[transcode-video-operation] (${$}) Will transcode ${P.length} quality levels`),0===P.length)return{error:"No quality levels selected for transcoding"};if(S(y).some((e=>e.includes("_240p")||e.includes("_480p")||e.includes("_720p")||e.includes("_1080p")||e.includes("_2160p"))))m.info(`[transcode-video-operation] (${$}) Transcoded files already exist, skipping transcoding`);else{m.info(`[transcode-video-operation] (${$}) No existing files found, starting transcoding...`);for(const e of P)try{m.info(`[transcode-video-operation] (${$}) Starting transcoding for quality: %sp`,e.id),await E(T,e,F,x),m.info(`[transcode-video-operation] (${$}) Successfully transcoded quality: %sp`,e.id)}catch(i){throw m.error(`[transcode-video-operation] (${$}) Failed to transcode quality %sp:`,e.id,i),i}m.info(`[transcode-video-operation] (${$}) All qualities transcoded successfully`)}const L=["#EXTM3U","#EXT-X-VERSION:3"];for(const i of P){const t=`${y}/${$}_${i.id}p.m3u8`;if(e.existsSync(t))switch(i.id){case 240:L.push("#EXT-X-STREAM-INF:BANDWIDTH=400000,RESOLUTION=426x240",`${$}_240p.m3u8`);break;case 480:L.push("#EXT-X-STREAM-INF:BANDWIDTH=1400000,RESOLUTION=854x480",`${$}_480p.m3u8`);break;case 720:L.push("#EXT-X-STREAM-INF:BANDWIDTH=2800000,RESOLUTION=1280x720",`${$}_720p.m3u8`);break;case 1080:L.push("#EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1920x1080",`${$}_1080p.m3u8`);break;case 2160:L.push("#EXT-X-STREAM-INF:BANDWIDTH=20000000,RESOLUTION=3840x2160",`${$}_2160p.m3u8`)}}e.writeFileSync(`${y}/${$}_playlist.m3u8`,L.join("\n")),m.info(`[transcode-video-operation] (${$}) Master playlist created: ${$}_playlist.m3u8`);const M=D;m.info(`[transcode-video-operation] (${$}) Creating virtual folder...`);const B=await(async(e,i=null)=>{try{const{FoldersService:t}=f,o=new t({schema:await u()}),r={name:{_eq:e}};i&&(r.parent={_eq:i});const n=await o.readByQuery({filter:r});if(n&&Array.isArray(n)&&n.length>0){const e=n[0]?.id||n[0]?.data?.id||n[0];return m.info(`[transcode-video-operation] (${$}) Found existing folder: ${e}`),String(e)}const a={name:e};i?(a.parent=i,m.info(`[transcode-video-operation] (${$}) Creating folder "${e}" with parent ${i}`)):m.info(`[transcode-video-operation] (${$}) Creating folder "${e}" at root`);const s=await o.createOne(a);m.debug(`[transcode-video-operation] (${$}) Folder creation response:`,JSON.stringify(s,null,2));const d=s?.id||s?.data?.id||("string"==typeof s?s:null);if(!d)throw new Error(`Failed to get folder ID from response: ${JSON.stringify(s)}`);return m.info(`[transcode-video-operation] (${$}) Created folder with ID: ${d}`),String(d)}catch(e){throw m.error(`[transcode-video-operation] (${$}) Error creating folder:`,e),e}})($,r);m.info(`[transcode-video-operation] (${$}) Created/using folder: ${B}`);const H=`${$}_thumb.jpg`;let z=null;const{FilesService:J}=f,V=new J({schema:await u()}),G={filename_disk:{_eq:H},storage:{_eq:_},folder:{_eq:B}},Q=await V.readByQuery({filter:G,limit:1});if(Q&&Array.isArray(Q)&&Q.length>0){const e=Q[0];z=e?.id||e?.data?.id||("string"==typeof e?e:null),z&&m.info(`[transcode-video-operation] (${$}) Thumbnail already exists in Directus: ${z}, reusing`)}const K=`${y}/${H}`;if(z)m.info(`[transcode-video-operation] (${$}) Skipping thumbnail extraction (already exists)`);else try{await(async(e,i)=>new Promise(((o,r)=>{t(`ffmpeg -y -i ${e} -ss 1 -vframes 1 -q:v 2 ${i}`,(e=>{e?(m.error(`[transcode-video-operation] (${$}) Error extracting thumbnail:`,e),r(e)):o(i)}))})))(T,K),m.info(`[transcode-video-operation] (${$}) Thumbnail extracted`)}catch(e){m.error(`[transcode-video-operation] (${$}) Error extracting thumbnail:`,e)}const Y=new Set;for(const t of P){const o=`${y}/${$}_${t.id}p.m3u8`;if(e.existsSync(o)){Y.add(`${$}_${t.id}p.m3u8`);const r=e.readFileSync(o,"utf-8").split("\n");for(const t of r){const o=t.trim();if(o&&!o.startsWith("#")){const t=i.basename(o);if(t.endsWith(".ts")&&t.startsWith($)){const i=`${y}/${t}`;e.existsSync(i)&&Y.add(t)}}}}}const Z={},ee=[];if(z)Z[i.basename(K)]=z,ee.push({filename_disk:i.basename(K),id:z});else if(e.existsSync(K))try{let e=null,o=null;try{const i=await(async e=>new Promise(((i,o)=>{t(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of json ${e}`,((e,t)=>{if(e)return m.error(`[transcode-video-operation] (${$}) Error getting image metadata:`,e),void o(e);try{const e=JSON.parse(t),r=e.streams?.[0];if(!r||!r.width||!r.height)return void o(new Error("Could not get image dimensions"));const n=parseInt(r.width),a=parseInt(r.height);i({width:n,height:a})}catch(e){m.error(`[transcode-video-operation] (${$}) Error parsing image metadata:`,e),o(e)}}))})))(K);e=i.width,o=i.height,m.info(`[transcode-video-operation] (${$}) Thumbnail dimensions: ${e}x${o}`)}catch(e){m.warn(`[transcode-video-operation] (${$}) Could not get thumbnail dimensions:`,e)}z=await b(K,B,{mimetype:"image/jpeg",width:e,height:o}),Z[i.basename(K)]=z,ee.push({filename_disk:i.basename(K),id:z}),m.info(`[transcode-video-operation] (${$}) Thumbnail uploaded: ${z}`)}catch(e){m.error(`[transcode-video-operation] (${$}) Error uploading thumbnail:`,e)}for(const i of Y){if(i===`${$}_playlist.m3u8`)continue;const t=`${y}/${i}`;if(e.existsSync(t))try{const e=await b(t,B);Z[i]=e,ee.push({filename_disk:i,id:e})}catch(e){m.error(`[transcode-video-operation] (${$}) Error uploading ${i}:`,e)}else m.warn(`[transcode-video-operation] (${$}) File not found on disk: ${i}`)}const ie="filename_disk"===n,te=ie?"filename_disk":"file IDs";m.info(`[transcode-video-operation] (${$}) Rebuilding playlists with ${te}...`);for(const t of P){const o=`${y}/${$}_${t.id}p.m3u8`;if(e.existsSync(o)){const r=k(o,Z,ie);e.writeFileSync(o,r);try{const e=await b(o,B);Z[i.basename(o)]=e,ee.push({filename_disk:i.basename(o),id:e}),m.info(`[transcode-video-operation] (${$}) Rebuilt and uploaded ${t.id}p playlist: ${e}`)}catch(e){m.error(`[transcode-video-operation] (${$}) Error re-uploading ${t.id}p playlist:`,e)}}}const oe=`${y}/${$}_playlist.m3u8`,re=e.readFileSync(oe,"utf-8").split("\n"),ne=[],ae=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;for(const e of re)if(e.startsWith("#")||""===e.trim())ne.push(e);else{let t=e.trim();if(t.startsWith("/assets/")&&(t=t.substring(8)),ae.test(t)&&!ie){ne.push(t);continue}const o=i.basename(t),r=Z[t]||Z[o];r?ie?ne.push(t):ne.push(r):ne.push(e)}e.writeFileSync(oe,ne.join("\n"));let se=null;try{se=await b(oe,B),Z[i.basename(oe)]=se,ee.push({filename_disk:i.basename(oe),id:se}),m.info(`[transcode-video-operation] (${$}) Master playlist uploaded: ${se}`)}catch(e){m.error(`[transcode-video-operation] (${$}) Error uploading master playlist:`,e)}m.info(`[transcode-video-operation] (${$}) All files uploaded to Directus: ${ee.length} files total`);if(!("local"===w(_)))try{m.info(`[transcode-video-operation] (${$}) Cleaning up local transcoded files (using cloud storage: ${_})...`);const i=S(y);for(const t of i){if(t===h.filename_disk)continue;const i=`${y}/${t}`;try{e.unlinkSync(i)}catch(e){m.warn(`[transcode-video-operation] (${$}) Could not delete local file ${t}:`,e)}}m.info(`[transcode-video-operation] (${$}) Local transcoded files cleaned up`)}catch(e){m.error(`[transcode-video-operation] (${$}) Error cleaning up local files:`,e)}if(O&&N)try{e.existsSync(N)&&(e.unlinkSync(N),m.info(`[transcode-video-operation] (${$}) Temporary source file cleaned up: ${N}`))}catch(e){m.warn(`[transcode-video-operation] (${$}) Could not delete temporary source file ${N}:`,e)}const de=[];for(const i of P){const t=`${y}/${$}_${i.id}p.m3u8`;e.existsSync(t)&&de.push(i.id)}return{master:{id:se,filename_disk:`${$}_playlist.m3u8`},metadata:{availableQualities:de,dimensions:{width:M.width,height:M.height,isVertical:M.isVertical},duration:M.duration,thumbnail:z},files:ee}}};export{o as default};
