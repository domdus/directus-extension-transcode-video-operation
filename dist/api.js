import e from"fs";import r from"path";import{exec as t}from"child_process";import o from"https";import i from"http";var n={id:"transcode-video-operation",handler:async({file:n,folder_id:a,playlist_reference_type:s="id",qualities:d=["240p","480p","720p","1080p","2160p"],threads:c=1,nice:l,storage_adapter:p="default",target_storage:f},{env:u,services:$,getSchema:m,logger:h})=>{if(!n)throw h.info("[transcode-video-operation] Input file missing"),new Error("Input file missing");if(!a)throw h.info("[transcode-video-operation] folder_id parameter is required"),new Error("folder_id parameter is required");let g;if("string"==typeof n)try{const{FilesService:e}=$,r=new e({schema:await m()});g=await r.readOne(n),h.info(`[transcode-video-operation] Fetched file from UUID: ${n}`)}catch(e){throw h.error(`[transcode-video-operation] Error fetching file with UUID ${n}:`,e),new Error(`Failed to fetch file with UUID ${n}: ${e instanceof Error?e.message:String(e)}`)}else g=n;if(!g?.filename_disk)throw h.info("[transcode-video-operation] Input file missing filename_disk"),new Error("Input file missing filename_disk");const v=g.filename_disk.split(".")[0];g.filename_disk.substr(g.filename_disk.lastIndexOf(".")+1);const y=u.STORAGE_LOCATIONS?Array.isArray(u.STORAGE_LOCATIONS)?u.STORAGE_LOCATIONS.map((e=>String(e).trim())):String(u.STORAGE_LOCATIONS).split(",").map((e=>e.trim())):[],w=y.length>0?y[0]:"local",_=e=>{const r=`STORAGE_${e.toUpperCase()}_ROOT`,t=u[r];return t?String(t):(h.warn(`[transcode-video-operation] (${v}) No storage found for location <%s>`,e),null)},S=e=>{const r=`STORAGE_${e.toUpperCase()}_DRIVER`,t=u[r];return t?String(t):(h.warn(`[transcode-video-operation] (${v}) No driver found for storage location <%s>, assuming 'local'`,e),"local")};let E;if("source"===p)E=g.storage||w;else if("custom"===p&&f){if(!(e=>{const r=`STORAGE_${e.toUpperCase()}_DRIVER`;return!!u[r]})(f)){const e=`Custom storage location "${f}" does not exist. Please ensure STORAGE_${f.toUpperCase()}_DRIVER is configured. Available locations: ${JSON.stringify(y)}`;throw h.error(`[transcode-video-operation] (${v}) ${e}`),new Error(e)}E=f,h.info(`[transcode-video-operation] (${v}) Using custom storage location: ${f}`)}else E=w;h.info(`[transcode-video-operation] (${v}) Using storage adapter: ${E}`);const b=S(E),k="local"===b;let T;const O=r=>e.readdirSync(r,"utf-8").filter((e=>e.startsWith(v))),F=async(t,o=null,i={})=>{try{const{FilesService:n}=$,a=new n({schema:await m()}),s=r.basename(t),d=s.substr(s.lastIndexOf(".")+1);if(!e.existsSync(t))throw new Error(`File does not exist: ${t}`);const c=e.statSync(t).size,l="local"===b;l||h.info(`[transcode-video-operation] (${v}) Uploading file: ${s} (${c} bytes) to storage: ${E}`);const p={ts:"video/mp2t",mp4:"video/mp4",jpeg:"image/jpeg",jpg:"image/jpeg",m3u8:"application/x-mpegurl"},f=E||i.storage,u=i.mimetype||p[d]||"application/octet-stream",g={filename_disk:{_eq:s},storage:{_eq:f}};g.folder=o?{_eq:o}:{_null:!0};const y=await a.readByQuery({filter:g,limit:1});if(y&&Array.isArray(y)&&y.length>0){const e=y[0],r=e?.id||e?.data?.id||("string"==typeof e?e:null);if(r)return h.info(`[transcode-video-operation] (${v}) File already exists in Directus: ${s} (ID: ${r}), reusing`),String(r)}const w={storage:f,filename_disk:s,filename_download:s,title:s,type:u,filesize:c};let _;void 0!==i.width&&null!==i.width&&(w.width=i.width),void 0!==i.height&&null!==i.height&&(w.height=i.height),o&&(w.folder=o);try{if(l)_=await a.createOne(w);else{const r=e.createReadStream(t);r.on("error",(e=>{h.error(`[transcode-video-operation] (${v}) File stream error for ${s}:`,e)})),_=await a.uploadOne(r,w)}try{const e=await a.readOne(_),r=e?.storage||e?.data?.storage;r!==f&&h.warn(`[transcode-video-operation] (${v}) Storage mismatch! Requested ${f} but file was stored in ${r}`)}catch(e){}}catch(e){const r=l?"registering":"uploading";throw h.error(`[transcode-video-operation] (${v}) Error ${r} file ${s}:`,e),e}if(!_||"string"!=typeof _&&"number"!=typeof _)throw h.error(`[transcode-video-operation] (${v}) Invalid file ID returned from uploadOne: ${_}`),new Error(`Failed to get file ID from uploadOne. Returned: ${_}`);return String(_)}catch(e){const r=e instanceof Error?e.message:String(e),o=e instanceof Error?e.stack:void 0;throw h.error(`[transcode-video-operation] (${v}) Error creating file record for ${t}: ${r}`),o&&h.error(`[transcode-video-operation] (${v}) Error stack: ${o}`),e}},x=(t,o,i=!1,n)=>{if(!e.existsSync(t))throw new Error(`Playlist file does not exist: ${t}`);if(0===e.statSync(t).size)throw new Error(`Playlist file is empty: ${t}`);let a=e.readFileSync(t,"utf-8");if(!a||0===a.trim().length)throw new Error(`Playlist file content is empty: ${t}`);const s=a.split("\n"),d=[],c=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;for(const e of s)if(e.startsWith("#")||""===e.trim())d.push(e);else{let t=e.trim();if(t.startsWith("/assets/")&&(t=t.substring(8)),t=t.trim(),c.test(t)&&!i){d.push(t);continue}const a=r.basename(t),s=o[t]||o[a]||o[t.trim()]||o[a.trim()];if(s)i?d.push(t):d.push(s);else{if(!i){const e=Object.keys(o).slice(0,10).join(", "),r=o.hasOwnProperty(t),i=o.hasOwnProperty(a);n&&n.warn(`[transcode-video-operation] File ID not found in map for: "${t}" (basename: "${a}"). Exact match: ${r}, Basename match: ${i}. Available keys (first 10): ${e}...`)}d.push(e)}}return d.join("\n")};function I(r,o,i,n){return new Promise(((a,s)=>{const d="win32"===process.platform,c=d||null==n?"":`nice -n ${n} `;d&&null!=n&&h.warn(`[transcode-video-operation] (${v}) Nice value (${n}) specified but running on Windows - nice command not available, ignoring priority setting`);const l=`${c}ffmpeg -y -i ${r} -threads ${i} ${o.options}`;t(l,((r,t,i)=>{if(r)return h.error(`[transcode-video-operation] (${v}) Error occured for quality: %s`,o.id),h.error(r.message),h.error(`stdout: ${t}`),h.error(`stderr: ${i}`),void s(new Error(`FFmpeg transcoding failed for quality ${o.id}p: ${r.message}. stderr: ${i}`));if(i&&(i.includes("not found")||i.includes("command not found")))return h.error(`[transcode-video-operation] (${v}) FFmpeg not found in stderr for quality: %s`,o.id),h.error(`stderr: ${i}`),void s(new Error(`FFmpeg command not found. stderr: ${i}`));const n=`${T}/${v}_${o.id}p.m3u8`;if(!e.existsSync(n)){const e=`Playlist file was not created: ${n}`;return h.error(`[transcode-video-operation] (${v}) ${e}`),i&&h.error(`[transcode-video-operation] (${v}) FFmpeg stderr: ${i}`),void s(new Error(e))}if(0===e.statSync(n).size){const e=`Playlist file is empty: ${n}`;return h.error(`[transcode-video-operation] (${v}) ${e}`),i&&h.error(`[transcode-video-operation] (${v}) FFmpeg stderr: ${i}`),void s(new Error(e))}if(!e.readFileSync(n,"utf-8").includes("#EXTM3U")){const e=`Playlist file does not contain valid HLS content: ${n}`;return h.error(`[transcode-video-operation] (${v}) ${e}`),i&&h.error(`[transcode-video-operation] (${v}) FFmpeg stderr: ${i}`),void s(new Error(e))}h.info(`[transcode-video-operation] (${v}) Transcoding finished for quality: %s`,o.id),a(t.trim())}))}))}h.info(`[transcode-video-operation] (${v}) Operation started`);const N=null!=c?parseInt(String(c),10):1,R=isNaN(N)||N<0?1:N;let A,P;if(null!=l){const e=parseInt(String(l),10);!isNaN(e)&&e>=0&&e<=19?A=e:h.warn(`[transcode-video-operation] (${v}) Invalid nice value: ${l}. Must be between 0 and 19. Ignoring.`)}let D=null,q=!1;const C=S(g.storage);if("local"===C){const t=_(g.storage);if(!t)return{error:`No storage found for location <${g.storage}>`};const o=process.env.PWD||"/directus";if(P=r.join(o,`${t}/${g.filename_disk}`),!e.existsSync(P))return h.error(`[transcode-video-operation] (${v}) Source file not found: %s`,P),{error:`Source file not found: ${P}`}}else{h.info(`[transcode-video-operation] (${v}) Source file is in cloud storage (${g.storage}, driver: ${C}), downloading to temporary location...`);try{let t=null;if("string"==typeof n?t=n:g.id?t=String(g.id):g.data?.id&&(t=String(g.data.id)),!t)return h.error(`[transcode-video-operation] (${v}) Cannot download source file: file ID not found. fileObject keys: ${Object.keys(g).join(", ")}`),{error:"Cannot download source file: file ID not found in fileObject"};const a=r.join(process.env.PWD||"/directus","tmp","transcode");if(!e.existsSync(a))try{e.mkdirSync(a,{recursive:!0,mode:493})}catch(r){const t=r instanceof Error?r.message:String(r);if(h.error(`[transcode-video-operation] (${v}) Failed to create temp directory ${a}: ${t}`),!t.includes("EACCES")&&!t.includes("permission denied"))return{error:`Failed to create temp directory ${a}: ${t}`};if(!e.existsSync(a))return{error:`Permission denied creating temp directory ${a}. Please ensure the directory exists on the host with proper permissions (chmod 755) or run: mkdir -p ./tmp && chmod 755 ./tmp`};h.warn(`[transcode-video-operation] (${v}) Temp directory exists but has permission issues. Continuing anyway.`)}const s=r.join(a,`${t}_${g.filename_disk}`);D=s;const d=u.PUBLIC_URL,c=()=>`http://${u.HOST&&"string"==typeof u.HOST&&""!==u.HOST.trim()?"0.0.0.0"===u.HOST.trim()?"localhost":u.HOST.trim():"localhost"}:${u.PORT&&"string"==typeof u.PORT&&""!==u.PORT.trim()?u.PORT.trim():u.PORT&&"number"==typeof u.PORT?String(u.PORT):"8055"}`;let l;if(d&&"string"==typeof d){const e=d.trim();l=""===e||"/"===e?c():e.endsWith("/")?e.slice(0,-1):e}else l=c();if(!t||"string"!=typeof t||""===t.trim())return h.error(`[transcode-video-operation] (${v}) Invalid fileId: ${t}`),{error:`Invalid file ID: ${t}`};const p=`${l}/assets/${t}`;h.info(`[transcode-video-operation] (${v}) Source file is in cloud storage (${C}), downloading to temporary location...`),await new Promise(((r,t)=>{try{new URL(p)}catch(e){return void t(new Error(`Invalid asset URL: ${p}. Error: ${e instanceof Error?e.message:String(e)}`))}(p.startsWith("https")?o:i).get(p,(o=>{if(200!==o.statusCode)return void t(new Error(`Failed to download file: HTTP ${o.statusCode}`));const i=e.createWriteStream(s);o.pipe(i),i.on("finish",(()=>{i.close(),r()})),i.on("error",t)})).on("error",t)})),P=D,q=!0,h.info(`[transcode-video-operation] (${v}) Source file downloaded to: ${P}`)}catch(e){const r=e instanceof Error?e.message:String(e),t=e instanceof Error?e.stack:void 0;return h.error(`[transcode-video-operation] (${v}) Error downloading source file from cloud storage: ${r}`),t&&h.error(`[transcode-video-operation] (${v}) Error stack: ${t}`),{error:`Failed to download source file from cloud storage: ${r}`}}}if(k){const e=_(E);if(!e)return{error:`No storage found for target location <${E}>`};const t=process.env.PWD||"/directus",o=r.dirname(P),i=_(g.storage);let n="";if(i){const e=r.join(t,i);o.startsWith(e)&&(n=r.relative(e,o))}T=n?r.join(t,e,n):r.join(t,e),h.info(`[transcode-video-operation] (${v}) Target storage is local (${E}), output directory: ${T}`)}else T=r.dirname(P),h.info(`[transcode-video-operation] (${v}) Target storage is cloud (${E}), output directory: ${T}`);h.info(`[transcode-video-operation] (${v}) File to be transcoded: %s`,P),h.info(`[transcode-video-operation] (${v}) Output directory: %s`,T),e.existsSync(T)||(e.mkdirSync(T,{recursive:!0}),h.info(`[transcode-video-operation] (${v}) Folder created`));try{await new Promise(((e,r)=>{t("which ffmpeg",((t,o,i)=>{!t&&o.trim()?e():r(new Error("FFmpeg is not installed or not found in PATH. Please install ffmpeg."))}))})),h.info(`[transcode-video-operation] (${v}) FFmpeg is available`)}catch(e){throw h.error(`[transcode-video-operation] (${v}) FFmpeg check failed: %s`,e instanceof Error?e.message:String(e)),e}const j=await new Promise(((e,r)=>{t(`ffprobe -v error -select_streams v:0 -show_entries stream=pix_fmt -of json ${P}`,((r,t)=>{if(r)return h.warn(`[transcode-video-operation] (${v}) Error checking bit depth, assuming 8-bit: %s`,r.message),void e(!1);try{const r=JSON.parse(t),o=r.streams?.[0]?.pix_fmt;e(o?.includes("10")||!1)}catch(r){h.warn(`[transcode-video-operation] (${v}) Error parsing bit depth check, assuming 8-bit`),e(!1)}}))}));j&&h.info(`[transcode-video-operation] (${v}) High bit depth detected, will convert to yuv420p`),h.info(`[transcode-video-operation] (${v}) Getting source video metadata...`);const U=await(async e=>new Promise(((r,o)=>{t(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height:format=duration -of json ${e}`,((e,t)=>{if(e)return h.error(`[transcode-video-operation] (${v}) Error getting video metadata:`,e),void o(e);try{const e=JSON.parse(t),i=e.streams?.[0],n=e.format;if(!i||!i.width||!i.height)return void o(new Error("Could not get video dimensions"));const a=parseInt(i.width),s=parseInt(i.height),d=n?.duration?Math.floor(1e3*parseFloat(n.duration)):0;r({width:a,height:s,isVertical:s>a,duration:d})}catch(e){h.error(`[transcode-video-operation] (${v}) Error parsing metadata:`,e),o(e)}}))})))(P).catch((e=>(h.error(`[transcode-video-operation] (${v}) Error getting source metadata:`,e),{width:99999,height:99999,isVertical:!1,duration:0}))),W=U.height;h.info(`[transcode-video-operation] (${v}) Source video resolution: ${U.width}x${W}`);const z=((e=!1)=>{const r="main",t=e?"format=yuv420p,":"";return[{id:240,options:`-vf "${t}scale=w='min(426,iw)':h='min(240,ih)':force_original_aspect_ratio=decrease,scale=trunc(iw/2)*2:trunc(ih/2)*2" -c:a aac -ar 48000 -c:v h264 -profile:v ${r} -crf 22 -sc_threshold 0 -g 48 -keyint_min 48 -hls_time 4 -hls_playlist_type vod -b:v 400k -maxrate 428k -bufsize 600k -b:a 64k -hls_segment_filename ${T}/${v}_240p_%03d.ts ${T}/${v}_240p.m3u8`},{id:480,options:`-vf "${t}scale=w='min(854,iw)':h='min(480,ih)':force_original_aspect_ratio=decrease,scale=trunc(iw/2)*2:trunc(ih/2)*2" -c:a aac -ar 48000 -c:v h264 -profile:v ${r} -crf 20 -sc_threshold 0 -g 48 -keyint_min 48 -hls_time 4 -hls_playlist_type vod -b:v 1400k -maxrate 1498k -bufsize 2100k -b:a 128k -hls_segment_filename ${T}/${v}_480p_%03d.ts ${T}/${v}_480p.m3u8`},{id:720,options:`-vf "${t}scale=w='min(1280,iw)':h='min(720,ih)':force_original_aspect_ratio=decrease,scale=trunc(iw/2)*2:trunc(ih/2)*2" -c:a aac -ar 48000 -c:v h264 -profile:v ${r} -crf 20 -sc_threshold 0 -g 48 -keyint_min 48 -hls_time 4 -hls_playlist_type vod -b:v 2800k -maxrate 2996k -bufsize 4200k -b:a 128k -hls_segment_filename ${T}/${v}_720p_%03d.ts ${T}/${v}_720p.m3u8`},{id:1080,options:`-vf "${t}scale=w='min(1920,iw)':h='min(1080,ih)':force_original_aspect_ratio=decrease,scale=trunc(iw/2)*2:trunc(ih/2)*2" -c:a aac -ar 48000 -c:v h264 -profile:v ${r} -crf 20 -sc_threshold 0 -g 48 -keyint_min 48 -hls_time 4 -hls_playlist_type vod -b:v 5000k -maxrate 5350k -bufsize 7500k -b:a 192k -hls_segment_filename ${T}/${v}_1080p_%03d.ts ${T}/${v}_1080p.m3u8`},{id:2160,options:`-vf "${t}scale=w='min(3840,iw)':h='min(2160,ih)':force_original_aspect_ratio=decrease,scale=trunc(iw/2)*2:trunc(ih/2)*2" -c:a aac -ar 48000 -c:v h264 -profile:v ${r} -crf 20 -sc_threshold 0 -g 48 -keyint_min 48 -hls_time 4 -hls_playlist_type vod -b:v 20000k -maxrate 21400k -bufsize 30000k -b:a 192k -hls_segment_filename ${T}/${v}_2160p_%03d.ts ${T}/${v}_2160p.m3u8`}]})(j);let M=["240p","480p","720p","1080p","2160p"];if(d)if(Array.isArray(d))M=d;else if("string"==typeof d)try{M=JSON.parse(d)}catch(e){h.warn(`[transcode-video-operation] (${v}) Could not parse qualities, using all:`,e)}const L=M.map((e=>{if("string"==typeof e){const r=e.replace(/p$/i,"");return parseInt(r,10)}return e})).filter((e=>!isNaN(e))),H={240:240,480:480,720:720,1080:1080,2160:2160};let X=z.filter((e=>L.includes(e.id)));const B=X.length;if(X=X.filter((e=>{const r=H[e.id];return!(r&&r>W)||(h.info(`[transcode-video-operation] (${v}) Skipping ${e.id}p (target: ${r}px, source: ${W}px) to prevent upscaling`),!1)})),B>X.length&&h.info(`[transcode-video-operation] (${v}) Filtered out ${B-X.length} quality level(s) that would require upscaling`),h.info(`[transcode-video-operation] (${v}) Selected qualities: ${L.join(", ")}`),h.info(`[transcode-video-operation] (${v}) Will transcode ${X.length} quality levels`),0===X.length)return{error:"No quality levels selected for transcoding"};if(O(T).some((e=>e.includes("_240p")||e.includes("_480p")||e.includes("_720p")||e.includes("_1080p")||e.includes("_2160p"))))h.info(`[transcode-video-operation] (${v}) Transcoded files already exist, skipping transcoding`);else{h.info(`[transcode-video-operation] (${v}) No existing files found, starting transcoding...`);for(const e of X)try{h.info(`[transcode-video-operation] (${v}) Starting transcoding for quality: %sp`,e.id),await I(P,e,R,A),h.info(`[transcode-video-operation] (${v}) Successfully transcoded quality: %sp`,e.id)}catch(r){throw h.error(`[transcode-video-operation] (${v}) Failed to transcode quality %sp:`,e.id,r),r}h.info(`[transcode-video-operation] (${v}) All qualities transcoded successfully`)}const G=["#EXTM3U","#EXT-X-VERSION:3"];for(const r of X){const t=`${T}/${v}_${r.id}p.m3u8`;if(e.existsSync(t)&&e.statSync(t).size>0)switch(r.id){case 240:G.push("#EXT-X-STREAM-INF:BANDWIDTH=400000,RESOLUTION=426x240",`${v}_240p.m3u8`);break;case 480:G.push("#EXT-X-STREAM-INF:BANDWIDTH=1400000,RESOLUTION=854x480",`${v}_480p.m3u8`);break;case 720:G.push("#EXT-X-STREAM-INF:BANDWIDTH=2800000,RESOLUTION=1280x720",`${v}_720p.m3u8`);break;case 1080:G.push("#EXT-X-STREAM-INF:BANDWIDTH=5000000,RESOLUTION=1920x1080",`${v}_1080p.m3u8`);break;case 2160:G.push("#EXT-X-STREAM-INF:BANDWIDTH=20000000,RESOLUTION=3840x2160",`${v}_2160p.m3u8`)}}if(G.length<=2)return h.error(`[transcode-video-operation] (${v}) No valid quality playlists found, cannot create master playlist`),{error:"No valid quality playlists found, cannot create master playlist"};const V=`${T}/${v}_master.m3u8`;if(e.writeFileSync(V,G.join("\n")),!e.existsSync(V)||0===e.statSync(V).size)return h.error(`[transcode-video-operation] (${v}) Failed to create master playlist: ${V}`),{error:`Failed to create master playlist: ${V}`};h.info(`[transcode-video-operation] (${v}) Master playlist created: ${v}_master.m3u8`);const J=U;h.info(`[transcode-video-operation] (${v}) Creating virtual folder...`);const Q=await(async(e,r=null)=>{try{const{FoldersService:t}=$,o=new t({schema:await m()}),i={name:{_eq:e}};r&&(i.parent={_eq:r});const n=await o.readByQuery({filter:i});if(n&&Array.isArray(n)&&n.length>0){const e=n[0]?.id||n[0]?.data?.id||n[0];return h.info(`[transcode-video-operation] (${v}) Found existing folder: ${e}`),String(e)}const a={name:e};r?(a.parent=r,h.info(`[transcode-video-operation] (${v}) Creating folder "${e}" with parent ${r}`)):h.info(`[transcode-video-operation] (${v}) Creating folder "${e}" at root`);const s=await o.createOne(a),d=s?.id||s?.data?.id||("string"==typeof s?s:null);if(!d)throw new Error(`Failed to get folder ID from response: ${JSON.stringify(s)}`);return h.info(`[transcode-video-operation] (${v}) Created folder with ID: ${d}`),String(d)}catch(e){throw h.error(`[transcode-video-operation] (${v}) Error creating folder:`,e),e}})(v,a);h.info(`[transcode-video-operation] (${v}) Created/using folder: ${Q}`);const K=`${v}_thumb.jpg`;let Y=null;const{FilesService:Z}=$,ee=new Z({schema:await m()}),re={filename_disk:{_eq:K},storage:{_eq:E},folder:{_eq:Q}},te=await ee.readByQuery({filter:re,limit:1});if(te&&Array.isArray(te)&&te.length>0){const e=te[0];Y=e?.id||e?.data?.id||("string"==typeof e?e:null),Y&&h.info(`[transcode-video-operation] (${v}) Thumbnail already exists in Directus: ${Y}, reusing`)}const oe=`${T}/${K}`;if(Y)h.info(`[transcode-video-operation] (${v}) Skipping thumbnail extraction (already exists)`);else try{if(await(async(r,o)=>new Promise(((i,n)=>{t(`ffmpeg -y -i ${r} -ss 1 -vframes 1 -q:v 2 ${o}`,((r,t,a)=>{if(r)return h.error(`[transcode-video-operation] (${v}) Error extracting thumbnail:`,r),a&&h.error(`[transcode-video-operation] (${v}) FFmpeg stderr: ${a}`),void n(r);if(!e.existsSync(o)){const e=`Thumbnail file was not created: ${o}`;return h.error(`[transcode-video-operation] (${v}) ${e}`),a&&h.error(`[transcode-video-operation] (${v}) FFmpeg stderr: ${a}`),void n(new Error(e))}if(0===e.statSync(o).size){const e=`Thumbnail file is empty: ${o}`;return h.error(`[transcode-video-operation] (${v}) ${e}`),a&&h.error(`[transcode-video-operation] (${v}) FFmpeg stderr: ${a}`),void n(new Error(e))}i(o)}))})))(P,oe),!e.existsSync(oe)||0===e.statSync(oe).size)throw new Error("Thumbnail extraction failed: file does not exist or is empty");h.info(`[transcode-video-operation] (${v}) Thumbnail extracted`)}catch(e){h.error(`[transcode-video-operation] (${v}) Error extracting thumbnail:`,e),Y=null}const ie={},ne=[];if(Y)ie[r.basename(oe)]=Y,ne.push({filename_disk:r.basename(oe),id:Y});else if(e.existsSync(oe)){if(0===e.statSync(oe).size){const e="local"===b?"register":"upload";h.error(`[transcode-video-operation] (${v}) Thumbnail file is empty, cannot ${e}`)}else try{let e=null,o=null;try{const r=await(async e=>new Promise(((r,o)=>{t(`ffprobe -v error -select_streams v:0 -show_entries stream=width,height -of json ${e}`,((e,t)=>{if(e)return h.error(`[transcode-video-operation] (${v}) Error getting image metadata:`,e),void o(e);try{const e=JSON.parse(t),i=e.streams?.[0];if(!i||!i.width||!i.height)return void o(new Error("Could not get image dimensions"));const n=parseInt(i.width),a=parseInt(i.height);r({width:n,height:a})}catch(e){h.error(`[transcode-video-operation] (${v}) Error parsing image metadata:`,e),o(e)}}))})))(oe);e=r.width,o=r.height,h.info(`[transcode-video-operation] (${v}) Thumbnail dimensions: ${e}x${o}`)}catch(e){h.warn(`[transcode-video-operation] (${v}) Could not get thumbnail dimensions:`,e)}Y=await F(oe,Q,{mimetype:"image/jpeg",width:e,height:o}),ie[r.basename(oe)]=Y,ne.push({filename_disk:r.basename(oe),id:Y});const i="local"===b?"registered":"uploaded";h.info(`[transcode-video-operation] (${v}) Thumbnail ${i}: ${Y}`)}catch(e){const r="local"===b?"registering":"uploading";h.error(`[transcode-video-operation] (${v}) Error ${r} thumbnail:`,e)}}const ae=new Set;for(const t of X){const o=`${T}/${v}_${t.id}p.m3u8`;if(e.existsSync(o)){const t=e.readFileSync(o,"utf-8").split("\n");for(const o of t){const t=o.trim();if(t&&!t.startsWith("#")){const o=r.basename(t);if(o.endsWith(".ts")&&o.startsWith(v)){const r=`${T}/${o}`;e.existsSync(r)&&ae.add(o)}}}}}h.info(`[transcode-video-operation] (${v}) Uploading ${ae.size} segment files...`);for(const r of ae){const t=`${T}/${r}`;if(e.existsSync(t))try{const e=await F(t,Q);ie[r]=e,ne.push({filename_disk:r,id:e})}catch(e){h.error(`[transcode-video-operation] (${v}) Error uploading segment ${r}:`,e)}else h.warn(`[transcode-video-operation] (${v}) Segment file not found on disk: ${r}`)}const se="filename_disk"===s,de=se?"filename_disk":"file IDs";h.info(`[transcode-video-operation] (${v}) Rebuilding playlists with ${de}...`);for(const t of X){const o=`${T}/${v}_${t.id}p.m3u8`;if(e.existsSync(o)){if(0===e.statSync(o).size){h.warn(`[transcode-video-operation] (${v}) Playlist file ${t.id}p.m3u8 is empty, skipping rebuild`);continue}const i=x(o,ie,se,h);if(!i||0===i.trim().length){const e="local"===b?"registration":"upload";h.warn(`[transcode-video-operation] (${v}) Rebuilt playlist content is empty for ${t.id}p, skipping ${e}`);continue}e.writeFileSync(o,i);try{const e=r.basename(o),t=await F(o,Q);ie[e]=t,ne.push({filename_disk:e,id:t})}catch(e){const r="local"===b?"registering":"uploading";h.error(`[transcode-video-operation] (${v}) Error ${r} ${t.id}p playlist:`,e)}}}if(!e.existsSync(V))return h.error(`[transcode-video-operation] (${v}) Master playlist file does not exist: ${V}`),{error:`Master playlist file does not exist: ${V}`};if(0===e.statSync(V).size)return h.error(`[transcode-video-operation] (${v}) Master playlist file is empty: ${V}`),{error:`Master playlist file is empty: ${V}`};const ce=e.readFileSync(V,"utf-8");if(!ce||0===ce.trim().length)return h.error(`[transcode-video-operation] (${v}) Master playlist content is empty: ${V}`),{error:`Master playlist content is empty: ${V}`};const le=ce.split("\n"),pe=[],fe=/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;for(const e of le)if(e.startsWith("#")||""===e.trim())pe.push(e);else{let t=e.trim();if(t.startsWith("/assets/")&&(t=t.substring(8)),fe.test(t)&&!se){pe.push(t);continue}const o=r.basename(t),i=ie[t]||ie[o];i?se?pe.push(t):pe.push(i):pe.push(e)}e.writeFileSync(V,pe.join("\n"));let ue=null;try{ue=await F(V,Q),ie[r.basename(V)]=ue,ne.push({filename_disk:r.basename(V),id:ue})}catch(e){const r="local"===b?"registering":"uploading";h.error(`[transcode-video-operation] (${v}) Error ${r} master playlist:`,e)}const $e="local"===b?"registered":"uploaded";if(h.info(`[transcode-video-operation] (${v}) All files ${$e} to Directus: ${ne.length} files total`),!k)try{h.info(`[transcode-video-operation] (${v}) Cleaning up local transcoded files (using cloud storage: ${E})...`);const r=O(T);for(const t of r){if(t===g.filename_disk)continue;const r=`${T}/${t}`;try{e.unlinkSync(r)}catch(e){h.warn(`[transcode-video-operation] (${v}) Could not delete local file ${t}:`,e)}}h.info(`[transcode-video-operation] (${v}) Local transcoded files cleaned up`)}catch(e){h.error(`[transcode-video-operation] (${v}) Error cleaning up local files:`,e)}if(q&&D)try{e.existsSync(D)&&(e.unlinkSync(D),h.info(`[transcode-video-operation] (${v}) Temporary source file cleaned up: ${D}`))}catch(e){h.warn(`[transcode-video-operation] (${v}) Could not delete temporary source file ${D}:`,e)}const me=[];for(const r of X){const t=`${T}/${v}_${r.id}p.m3u8`;e.existsSync(t)&&me.push(r.id)}return{master:{id:ue,filename_disk:`${v}_master.m3u8`},metadata:{availableQualities:me,dimensions:{width:J.width,height:J.height,isVertical:J.isVertical},duration:J.duration,thumbnail:Y},files:ne}}};export{n as default};
